ΣΥΣ/ΠΡΟ 2019-2020
ΕΡΓΑΣΙΑ 3
Θεοδόσης Παιδάκης - 1115201500118

Γενικό πρωτόκολλο επικοινωνίας:
    - Γράφω μαζικά στον αποδέκτη το μήνυμα που θένω να στείλω, βάζοντας τον τερματικό
    χαρακτήρα '/0' στο τέλος. Αυτή τη δουλεία την κάνει η OverAndOut() συνάρτηση μου.

    - Το buffersize που λαμβάνω, μπορεί να αλλαχθεί σε οποιοδήποτε νούμερο και εννοείται
    δεν χρειάζεται τα εκτελέσιμα μου να διαβάζουν το ίδιο νούμερο μέγεθος buffer.

whoClient :
    - Ξεκινάει διαβάζοντας όλα τα ερωτήματα του αρχείου και τα τοποθετεί σε μια λίστα.
    
    - Κάνοντας traverse την λίστα, δίνουμε από ένα ερώτημα στο κάθε thread,
    και παράλληλα ακρατάμε τον αριθμό των threads που έχουν διαβάσει ερώτημα,
    ώστε να γνωρίζουμε πότε θα φτάσουμε στο τελευταίο.

    - Τότε κάνουμε broadcast σε όλα τα υπόλοιπα threads, που είχαν λοκάρει με την χρήση
    condition variable, και στέλνουν ταυτόχρονα τα ερωτήματα τους. 

    - Όταν διαβάζει ο whoClient πίσω τις απαντήσεις έχουμε ειδικό πρωτόκολλο.
    Το κάθε νήμα που σερβερ που έχει την ευθύνη για μια ερώτηση, στέλνει ομαδικά όλες τις
    απαντήσεις από τους workers που το είχαν αναλάβει.
    - Για να ξεχωρίζουμε τις απαντήσεις, γράφεται ενδίαμεσα ο χαρακτήρας '$' σαν
    διαχωριστικό. Στο τέλος του μαζικού μηνύματος, στέλνεται ο τερματικός χαρακτήρας,
    ώστε να καταλάβει ο whoClient ότι τα διάβασε όλα.

    - Στο τέλος, αν δει το thread ότι υπάρχουν ερωτήματα αδιάβαστα, ξεκινάει πάλι
    από την αρχή και επαναλαμβάνει την διαδικασία.

    - Οπότε, το πρόγραμμα δουλεύει για οποιοδήποτε πλήθος ερωτημάτων σε συνδυασμό με το
    πλήθος των threads.

whoServer:
    - Ξεκινώντας ο σέρβερ, δημιουργεί τα κατάλληλα listening sockets για να ακούει workers και ερωτήματα.

    - Με μια select(), περιμένει και δέχεται είτε ερωτήματα είτε workers. Ανάλογα τον αποστολέα,
    στον buffer προσθέτουμε τον socketfd του και ενα 0 ή 1, για worker ή ερώτημα αντίστοιχα.

    - Εκείνη τη στιγμή στέλνεται signal σε ένα thread, γιαν να ξυπνήσει και αναλαμβάνει
    την επεξεργασία του αιτήματος.
    - Το busy waiting το αποφεύγουμε με την χρήση condition variables, όπως φαίνεται στην
    socketDistribution().

    - Λαμβάνουμε αρχικά τα μηνύματα των workers και αποθηκεύουμε τα port τους σε μια global λίστα.

    - Όπως φαίνεται απο το stdout, έχω δημιουργήσει έτσι τον τρόπο επικοινωνίας, ώστε να
    γνωρίζει το κάθε πρόγραμμα αν ο αποδέκτης του διάβασε το μήνυμα επιτυχώς.

    - Έτσι γνωρίζω πότε είναι ασφαλές να κλείσω ένα socket χωρίς να επηρεαστεί λανθασμένα
    το πρόγραμμα και δεν υπάρχουν τέτιου είδους leaks.

    - Όπου μπορώ κάνω free την δυναμικά allocated μνήμη μου.

    - Το ctrl-c, το κάνω catch με signal και κλείνω όλα τα δημιουργημένα threads μου,
    ώστε να τερματίσει όσο πιο ομαλά γίνεται.

master:
    - Αρχικά, ο κάθε worker διαβάζει τα αρχεία εγγραφών, τα τοποθετεί σε δομές δεδομένων
     και κάνει extract ορισμένα στατιστικά, τα οποία και στέλνει στον σέρβερ.

    - Ακολουθείται το γενικό πρωτόκολλο επικοινωνίας.

    - Δεν έχω υλοποιήσει τις συναρτήεις που ζητούνται, επειδή δεν πρόλαβα.
    Οπότε, την απάντηση του worker, την βάζω σε ένα πλαίσιο, τύπου placeholder.
    Περιέχει κάποιες πληροφορίες σχετικά με το port του και το ερώτημα που δέχτηκε,
    ώστε όταν φτάσει η απάντηση στον σέρβερ και client, να φαίνεται ότι έχει γίνει σωστά
    η επικοινωνία και έχει περάσει από όλα τα στάδια.

    - Παρένθεση: Έκανα ερώτηση στο piazza, σχετικά με την παραπάνω έλλειψη και η
    απάντηση ήταν πως η υλοποίηση των συναρτήσεων του master, πιάνουν το 
    1-3% του συνολικού βαθμού, μιας και εξετάστηκαν στις προηγούμενες εργασίες.
    Επέλεξα να δώσω την προσοχή μου στην επικοινωνία, που είναι και το
    ζητούμενο της άσκησης.